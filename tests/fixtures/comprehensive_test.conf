# Comprehensive Logstash Configuration Test
# This file covers ALL grammar rules from grammar.treetop

# ============================================================================
# INPUT SECTION - Tests: plugin_section, plugin, attribute, value types
# ============================================================================
input {
  # Test: Plugin with string attributes
  file {
    path => "/var/log/syslog"
    start_position => "beginning"
    sincedb_path => '/dev/null'
  }

  # Test: Plugin with number attributes
  tcp {
    port => 5000
    host => "0.0.0.0"
  }

  # Test: Plugin with boolean attributes
  beats {
    port => 5044
    ssl => true
    ssl_verify_mode => false
  }

  # Test: Plugin with array attributes
  stdin {
    tags => ["input", "test", "stdin"]
    add_field => ["field1", "value1", "field2", "value2"]
  }

  # Test: Plugin with hash attributes
  http {
    port => 8080
    additional_codecs => {
      "application/json" => "json"
      "text/plain" => "plain"
    }
    response_headers => {
      200 => "OK"
      404 => "Not Found"
    }
  }

  # Test: Plugin with nested plugin (codec)
  udp {
    port => 514
    codec => json {
      charset => "UTF-8"
    }
  }

  # Test: Bareword values
  syslog {
    port => 514
    type => syslog
  }
}

# ============================================================================
# FILTER SECTION - Tests: all expression types, conditions, branches
# ============================================================================

filter {
  # Test: Simple plugin
  mutate {
    add_field => { "test_field" => "test_value" }
  }

  # ========================================================================
  # Test: Compare expressions (==, !=, <, >, <=, >=)
  # ========================================================================
  if [status] == 200 {
    mutate {
      add_tag => ["success"]
    }
  }

  if [status] != 404 {
    mutate {
      add_tag => ["not_404"]
    }
  }

  if [response_time] < 100 {
    mutate {
      add_tag => ["fast"]
    }
  }

  if [response_time] > 1000 {
    mutate {
      add_tag => ["slow"]
    }
  }

  if [status] >= 200 {
    mutate {
      add_tag => ["ok_or_higher"]
    }
  }

  if [status] <= 299 {
    mutate {
      add_tag => ["2xx"]
    }
  }

  # ========================================================================
  # Test: Regex expressions (=~, !~)
  # ========================================================================
  if [message] =~ /error/ {
    mutate {
      add_tag => ["has_error"]
    }
  }

  if [message] =~ "warning" {
    mutate {
      add_tag => ["has_warning"]
    }
  }

  if [path] !~ /\/tmp\// {
    mutate {
      add_tag => ["not_tmp"]
    }
  }

  # Test: Complex regex patterns
  if [url] =~ /https?:\/\/.*\.com/ {
    mutate {
      add_tag => ["dotcom_url"]
    }
  }

  # ========================================================================
  # Test: In expressions
  # ========================================================================
  if [status] in [200, 201, 204] {
    mutate {
      add_tag => ["success_status"]
    }
  }

  if [type] in ["syslog", "apache", "nginx"] {
    mutate {
      add_tag => ["known_type"]
    }
  }

  # ========================================================================
  # Test: Not in expressions
  # ========================================================================
  if [status] not in [400, 404, 500] {
    mutate {
      add_tag => ["not_error"]
    }
  }

  # Test: not_in_operator with whitespace/comments
  if [level] not   in ["DEBUG", "TRACE"] {
    mutate {
      add_tag => ["important"]
    }
  }

  # ========================================================================
  # Test: Negative expressions (!)
  # ========================================================================
  if ![field] {
    mutate {
      add_tag => ["field_missing"]
    }
  }

  if !([status] >= 400) {
    mutate {
      add_tag => ["not_error_status"]
    }
  }

  # ========================================================================
  # Test: Boolean expressions (and, or, xor, nand)
  # ========================================================================
  if [status] >= 200 and [status] < 300 {
    mutate {
      add_tag => ["2xx_range"]
    }
  }

  if [status] == 200 or [status] == 304 {
    mutate {
      add_tag => ["ok_or_not_modified"]
    }
  }

  if [level] == "ERROR" xor [level] == "FATAL" {
    mutate {
      add_tag => ["exclusive_error"]
    }
  }

  if [status] nand [error] {
    mutate {
      add_tag => ["nand_test"]
    }
  }

  # Test: Complex boolean expressions
  if ([status] >= 200 and [status] < 300) or [status] == 304 {
    mutate {
      add_tag => ["success_or_cached"]
    }
  }

  if [type] == "apache" and ([status] >= 400 or [message] =~ /error/) {
    mutate {
      add_tag => ["apache_error"]
    }
  }

  # ========================================================================
  # Test: Nested conditions (parentheses)
  # ========================================================================
  if ([field1] and [field2]) or ([field3] or [field4]) {
    mutate {
      add_tag => ["complex_condition"]
    }
  }

  # ========================================================================
  # Test: Selector (field references)
  # ========================================================================
  if [field] {
    mutate {
      add_field => { "has_field" => "true" }
    }
  }

  if [nested][field] {
    mutate {
      add_field => { "has_nested" => "true" }
    }
  }

  if [deeply][nested][field][path] {
    mutate {
      add_field => { "has_deep_nested" => "true" }
    }
  }

  # ========================================================================
  # Test: Branch with else if and else
  # ========================================================================
  if [status] >= 200 and [status] < 300 {
    mutate {
      add_tag => ["2xx"]
    }
  } else if [status] >= 300 and [status] < 400 {
    mutate {
      add_tag => ["3xx"]
    }
  } else if [status] >= 400 and [status] < 500 {
    mutate {
      add_tag => ["4xx"]
    }
  } else if [status] >= 500 {
    mutate {
      add_tag => ["5xx"]
    }
  } else {
    mutate {
      add_tag => ["unknown_status"]
    }
  }

  # ========================================================================
  # Test: Multiple else if branches
  # ========================================================================
  if [level] == "DEBUG" {
    mutate { add_tag => ["debug"] }
  } else if [level] == "INFO" {
    mutate { add_tag => ["info"] }
  } else if [level] == "WARN" {
    mutate { add_tag => ["warn"] }
  } else if [level] == "ERROR" {
    mutate { add_tag => ["error"] }
  } else if [level] == "FATAL" {
    mutate { add_tag => ["fatal"] }
  } else {
    mutate { add_tag => ["unknown_level"] }
  }

  # ========================================================================
  # Test: Nested branches
  # ========================================================================
  if [type] == "apache" {
    if [status] >= 400 {
      if [status] >= 500 {
        mutate {
          add_tag => ["apache_server_error"]
        }
      } else {
        mutate {
          add_tag => ["apache_client_error"]
        }
      }
    }
  }

  # ========================================================================
  # Test: Grok with array match patterns
  # ========================================================================
  grok {
    match => [
      "message", "%{COMBINEDAPACHELOG}",
      "message", "%{COMMONAPACHELOG}"
    ]
  }

  # ========================================================================
  # Test: Date plugin
  # ========================================================================
  date {
    match => ["timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss"]
    target => "@timestamp"
    timezone => "UTC"
  }

  # ========================================================================
  # Test: GeoIP plugin
  # ========================================================================
  geoip {
    source => "client_ip"
    target => "geoip"
    database => "/usr/share/GeoIP/GeoLite2-City.mmdb"
  }

  # ========================================================================
  # Test: Ruby plugin with code
  # ========================================================================
  ruby {
    code => "event.set('custom_field', event.get('field1') + event.get('field2'))"
  }

  # ========================================================================
  # Test: Mutate with various operations
  # ========================================================================
  mutate {
    add_field => {
      "field1" => "value1"
      "field2" => "value2"
      "nested_field" => "%{[source][field]}"
    }
    remove_field => ["temp_field", "debug_field"]
    rename => {
      "old_name" => "new_name"
    }
    replace => {
      "field" => "new_value"
    }
    convert => {
      "port" => "integer"
      "duration" => "float"
    }
    gsub => [
      "message", "/", "_",
      "path", "\\", "/"
    ]
    split => {
      "tags" => ","
    }
    join => {
      "tags" => ","
    }
    strip => ["field1", "field2"]
    lowercase => ["field"]
    uppercase => ["field"]
  }

  # ========================================================================
  # Test: Drop plugin
  # ========================================================================
  if [drop_this] {
    drop {}
  }

  # ========================================================================
  # Test: Clone plugin
  # ========================================================================
  clone {
    clones => ["cloned"]
  }

  # ========================================================================
  # Test: Fingerprint plugin
  # ========================================================================
  fingerprint {
    source => ["field1", "field2"]
    target => "fingerprint"
    method => "SHA256"
  }

  # ========================================================================
  # Test: JSON plugin
  # ========================================================================
  json {
    source => "message"
    target => "parsed"
  }

  # ========================================================================
  # Test: KV plugin
  # ========================================================================
  kv {
    source => "message"
    field_split => "&"
    value_split => "="
  }

  # ========================================================================
  # Test: CSV plugin
  # ========================================================================
  csv {
    source => "message"
    separator => ","
    columns => ["col1", "col2", "col3"]
  }

  # ========================================================================
  # Test: Useragent plugin
  # ========================================================================
  useragent {
    source => "agent"
    target => "user_agent"
  }

  # ========================================================================
  # Test: Aggregate plugin
  # ========================================================================
  aggregate {
    task_id => "%{transaction_id}"
    code => "map['count'] ||= 0; map['count'] += 1"
    push_map_as_event_on_timeout => true
    timeout => 120
  }

  # ========================================================================
  # Test: Elapsed plugin
  # ========================================================================
  elapsed {
    start_tag => "start"
    end_tag => "end"
    unique_id_field => "transaction_id"
  }

  # ========================================================================
  # Test: Throttle plugin
  # ========================================================================
  throttle {
    before_count => 3
    after_count => 5
    period => 60
    key => "%{host}"
  }

  # ========================================================================
  # Test: Sleep plugin
  # ========================================================================
  sleep {
    time => "1"
  }

  # ========================================================================
  # Test: Metrics plugin
  # ========================================================================
  metrics {
    meter => "events"
    add_tag => "metric"
  }

  # ========================================================================
  # Test: All value types in hash
  # ========================================================================
  mutate {
    add_field => {
      "string_field" => "string_value"
      'single_quoted' => 'value'
      "number_field" => 123
      "float_field" => 45.67
      "negative_number" => -100
      "boolean_true" => true
      "boolean_false" => false
      "array_field" => [1, 2, 3]
      "nested_hash" => {
        "inner_key" => "inner_value"
      }
      "selector_field" => "%{[field][subfield]}"
    }
  }

  # ========================================================================
  # Test: Hash with different key types
  # ========================================================================
  mutate {
    add_field => {
      "string_key" => "value1"
      bareword_key => "value2"
      123 => "numeric_key"
    }
  }

  # ========================================================================
  # Test: Empty structures
  # ========================================================================
  mutate {
    add_field => {}
  }

  if [field] {
    mutate {
      add_field => { "empty_array" => [] }
    }
  }

  # ========================================================================
  # Test: Bareword minimum length (2 characters)
  # ========================================================================
  ab {
    cd => "value"
  }

  _a {
    _b => "value"
  }

  # ========================================================================
  # Test: Name with hyphens and numbers
  # ========================================================================
  plugin-with-hyphens {
    field-with-hyphens => "value"
  }

  9plugin {
    9field => "value"
  }

  # ========================================================================
  # Test: Escaped characters in strings
  # ========================================================================
  mutate {
    add_field => {
      "escaped_quote" => "say \"hello\""
      "escaped_backslash" => "path\\to\\file"
      "newline" => "line1\nline2"
      "tab" => "col1\tcol2"
      "carriage_return" => "line1\rline2"
    }
  }

  # ========================================================================
  # Test: Special characters in regex
  # ========================================================================
  if [message] =~ /\[ERROR\]/ {
    mutate { add_tag => ["bracketed_error"] }
  }

  if [path] =~ /\/var\/log\/.*\.log/ {
    mutate { add_tag => ["log_file"] }
  }

  if [email] =~ /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/ {
    mutate { add_tag => ["valid_email"] }
  }

  # ========================================================================
  # Test: Method calls in conditions (rvalue position)
  # ========================================================================

  # Test: Simple method call with string argument
  if [result] == sprintf("%{field}") {
    mutate {
      add_tag => ["sprintf_match"]
    }
  }

  # Test: Method call with multiple arguments
  if [formatted] == format("Hello %s", "World") {
    mutate {
      add_tag => ["format_match"]
    }
  }

  # Test: Method call with selector argument
  if [uppercase_name] == upper([name]) {
    mutate {
      add_tag => ["upper_match"]
    }
  }

  # Test: Method call with number arguments
  if [sum] == add(1, 2, 3) {
    mutate {
      add_tag => ["add_match"]
    }
  }

  # Test: Method call with no arguments
  if [timestamp] == now() {
    mutate {
      add_tag => ["now_match"]
    }
  }

  # Test: Nested method calls
  if [result] == upper(lower([field])) {
    mutate {
      add_tag => ["nested_method_match"]
    }
  }

  # Test: Method call in complex boolean expression
  if [type] == "user" and [name] == upper([username]) {
    mutate {
      add_tag => ["complex_method_condition"]
    }
  }

  # Test: Method call with array argument
  if [joined] == join(["a", "b", "c"]) {
    mutate {
      add_tag => ["join_match"]
    }
  }

  # Test: Multiple method calls in same condition
  if sprintf("%{field1}") == format("%s", [field2]) {
    mutate {
      add_tag => ["multiple_methods"]
    }
  }

  # Test: Method call in or expression
  if [value] == method1([field]) or [value] == method2([field]) {
    mutate {
      add_tag => ["method_or_condition"]
    }
  }

  # Test: Method call with escaped characters in string
  if [path] == normalize("path\\to\\file") {
    mutate {
      add_tag => ["escaped_in_method"]
    }
  }

  # Test: Method call with field interpolation
  if [result] == sprintf("%{[nested][field]}") {
    mutate {
      add_tag => ["nested_field_interpolation"]
    }
  }

  # Test: Deeply nested method calls (3 levels)
  if [result] == upper(lower(trim([field]))) {
    mutate {
      add_tag => ["deeply_nested_methods"]
    }
  }

  # Test: Method call in not equal comparison
  if [value] != default() {
    mutate {
      add_tag => ["method_not_equal"]
    }
  }

  # Test: Method call in greater than comparison
  if [count] > calculate([base]) {
    mutate {
      add_tag => ["method_greater_than"]
    }
  }

  # Test: Method call with mixed argument types
  if [result] == process("string", 123, [field]) {
    mutate {
      add_tag => ["mixed_args_method"]
    }
  }

  # Test: Method call in negative expression
  if ![field] or [value] == fallback() {
    mutate {
      add_tag => ["method_with_negative"]
    }
  }

  # Test: Method call in parenthesized expression
  if ([status] == 200 and [name] == upper([user])) or [admin] {
    mutate {
      add_tag => ["method_in_parentheses"]
    }
  }
}

# ============================================================================
# OUTPUT SECTION - Tests: output plugins with various configurations
# ============================================================================
output {
  # Test: Elasticsearch output
  elasticsearch {
    hosts => ["localhost:9200", "es-node2:9200"]
    index => "logstash-%{+YYYY.MM.dd}"
    document_id => "%{[@metadata][fingerprint]}"
    user => "elastic"
    password => "changeme"
  }

  # Test: File output with codec
  file {
    path => "/var/log/logstash/output-%{+YYYY-MM-dd}.log"
    codec => line {
      format => "%{message}"
    }
  }

  # Test: Stdout output
  stdout {
    codec => rubydebug {
      metadata => true
    }
  }

  # Test: Conditional output
  if [type] == "apache" {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "apache-%{+YYYY.MM.dd}"
    }
  }

  if [type] == "nginx" {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "nginx-%{+YYYY.MM.dd}"
    }
  } else {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "other-%{+YYYY.MM.dd}"
    }
  }

  # Test: HTTP output
  http {
    url => "http://example.com/api/logs"
    http_method => "post"
    format => "json"
    headers => {
      "Content-Type" => "application/json"
      "Authorization" => "Bearer ${TOKEN}"
    }
  }

  # Test: Kafka output
  kafka {
    bootstrap_servers => "kafka1:9092,kafka2:9092"
    topic_id => "logstash"
    codec => json
  }

  # Test: Redis output
  redis {
    host => "localhost"
    port => 6379
    data_type => "list"
    key => "logstash"
  }

  # Test: TCP output
  tcp {
    host => "remote-host"
    port => 5000
    codec => json_lines
  }

  # Test: UDP output
  udp {
    host => "remote-host"
    port => 514
  }

  # Test: S3 output
  s3 {
    region => "us-east-1"
    bucket => "my-logs-bucket"
    prefix => "logstash/%{+YYYY}/%{+MM}/%{+dd}/"
    codec => json_lines
  }

  # Test: Email output
  email {
    to => "admin@example.com"
    from => "logstash@example.com"
    subject => "Alert: %{message}"
    body => "Event details: %{@timestamp} - %{message}"
    via => "smtp"
    options => {
      address => "smtp.example.com"
      port => 587
      enable_starttls_auto => true
      authentication => "plain"
      user_name => "user"
      password => "pass"
    }
  }

  # Test: Pipe output
  pipe {
    command => "/usr/bin/process-logs.sh"
  }

  # Test: Null output (for testing)
  null {}
}
